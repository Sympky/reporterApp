<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreVulnerabilityRequest;
use App\Http\Requests\UpdateVulnerabilityRequest;
use App\Http\Requests\ImportTemplatesRequest;
use App\Http\Requests\ImportVulnerabilitiesRequest;
use App\Models\Vulnerability;
use App\Models\Project;
use App\Models\Client;
use App\Services\TemplateImportService;
use App\Services\VulnerabilityImportService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class VulnerabilityController extends Controller
{
    protected TemplateImportService $templateImportService;
    protected VulnerabilityImportService $vulnerabilityImportService;

    public function __construct(
        TemplateImportService $templateImportService,
        VulnerabilityImportService $vulnerabilityImportService
    ) {
        $this->templateImportService = $templateImportService;
        $this->vulnerabilityImportService = $vulnerabilityImportService;
    }

    /**
     * Display a listing of the resource for a specific project.
     */
    public function index(Project $project)
    {
        // Fetch vulnerabilities for the specified project
        $vulnerabilities = $project->vulnerabilities;

        // Return the vulnerabilities as a JSON response
        return response()->json($vulnerabilities);
    }

    /**
     * Display a listing of all vulnerabilities.
     */
    public function allVulnerabilities()
    {
        $vulnerabilities = Vulnerability::with(['project.client'])
            ->where('is_template', false)
            ->orderBy('created_at', 'desc')
            ->get();

        // Map the vulnerabilities to include project and client names
        $vulnerabilitiesWithDetails = $vulnerabilities->map(function ($vulnerability) {
            return [
                'id' => $vulnerability->id,
                'project_id' => $vulnerability->project_id,
                'client_id' => $vulnerability->project->client->id,
                'project_name' => $vulnerability->project->name,
                'client_name' => $vulnerability->project->client->name,
                'name' => $vulnerability->name,
                'description' => $vulnerability->description,
                'severity' => $vulnerability->severity,
                'cvss' => $vulnerability->cvss,
                'cve' => $vulnerability->cve,
                'remediation' => $vulnerability->recommendations,
                'discovered_at' => $vulnerability->discovered_at,
                'impact_score' => $vulnerability->impact_score,
                'likelihood_score' => $vulnerability->likelihood_score,
                'remediation_score' => $vulnerability->remediation_score,
            ];
        });

        $projects = Project::with('client')
            ->get()
            ->map(function ($project) {
                return [
                    'id' => $project->id,
                    'name' => $project->name,
                    'client_id' => $project->client_id,
                    'client_name' => $project->client->name,
                ];
            });
            
        // Get vulnerability templates with all relevant fields
        $templates = Vulnerability::where('is_template', true)
            ->orderBy('created_at', 'desc')
            ->get()
            ->map(function ($template) {
                return [
                    'id' => $template->id,
                    'name' => $template->name,
                    'description' => $template->description,
                    'severity' => $template->severity,
                    'cvss' => $template->cvss,
                    'cve' => $template->cve,
                    'recommendations' => $template->recommendations,
                    'impact' => $template->impact,
                    'references' => $template->references,
                    'tags' => $template->tags,
                    'likelihood_score' => $template->likelihood_score,
                    'remediation_score' => $template->remediation_score,
                    'impact_score' => $template->impact_score,
                    'affected_resources' => $template->affected_resources,
                ];
            });

        return Inertia::render('vulnerabilities/index', [
            'vulnerabilities' => $vulnerabilitiesWithDetails,
            'projects' => $projects,
            'templates' => $templates,
        ]);
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request, Project $project)
    {
        // Validate the request data
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'required|string',
            'severity' => 'required|string|in:critical,high,medium,low,info',
            'cvss' => 'nullable|numeric|min:0|max:10',
            'cve' => 'nullable|string|max:255',
            'recommendations' => 'nullable|string',
            'impact' => 'nullable|string',
            'status' => 'nullable|string',
            'remediation' => 'nullable|string',
            'remediation_steps' => 'nullable|string',
            'proof_of_concept' => 'nullable|string',
            'affected_components' => 'nullable|string',
            'notes' => 'nullable|string',
            'discovered_at' => 'nullable|date',
            'impact_score' => 'nullable|string|in:critical,high,medium,low,info',
            'likelihood_score' => 'nullable|string|in:critical,high,medium,low,info',
            'remediation_score' => 'nullable|string|in:critical,high,medium,low,info',
        ]);

        // Ensure severity is lowercase to match database constraints
        if (isset($validated['severity']) && $validated['severity'] !== null) {
            $validated['severity'] = strtolower($validated['severity']);
        }
        
        // Automatically set discovered_at to current time if not provided
        if (!isset($validated['discovered_at']) || empty($validated['discovered_at'])) {
            $validated['discovered_at'] = now();
        }

        // Create a new vulnerability
        $vulnerability = new Vulnerability($validated);
        $vulnerability->project_id = $project->id;
        $vulnerability->created_by = Auth::id();
        $vulnerability->updated_by = Auth::id();
        $vulnerability->save();

        // Return JSON response
        return response()->json($vulnerability, 201);
    }

    /**
     * Store a vulnerability from the vulnerabilities page.
     */
    public function storeVulnerability(Request $request)
    {
        // Validate the request data
        $validated = $request->validate([
            'project_id' => 'required|exists:projects,id',
            'name' => 'required|string|max:255',
            'description' => 'required|string',
            'severity' => 'required|string|in:critical,high,medium,low,info',
            'cvss' => 'nullable|numeric|min:0|max:10',
            'cve' => 'nullable|string|max:255',
            'status' => 'nullable|string',
            'remediation_steps' => 'nullable|string',
            'proof_of_concept' => 'nullable|string',
            'affected_components' => 'nullable|string',
            'notes' => 'nullable|string',
            'impact' => 'nullable|string',
            'discovered_at' => 'nullable|date',
            'impact_score' => 'nullable|string|in:critical,high,medium,low,info',
            'likelihood_score' => 'nullable|string|in:critical,high,medium,low,info',
            'remediation_score' => 'nullable|string|in:critical,high,medium,low,info',
        ]);

        // Ensure severity is lowercase to match database constraints
        if (isset($validated['severity']) && $validated['severity'] !== null) {
            $validated['severity'] = strtolower($validated['severity']);
        }
        
        // Automatically set discovered_at to current time if not provided
        if (!isset($validated['discovered_at']) || empty($validated['discovered_at'])) {
            $validated['discovered_at'] = now();
        }

        // Create a new vulnerability
        $vulnerability = new Vulnerability($validated);
        $vulnerability->created_by = Auth::id();
        $vulnerability->updated_by = Auth::id();
        $vulnerability->save();

        // Check if we're coming from a project page
        if ($request->header('Referer') && strpos($request->header('Referer'), 'projects/') !== false) {
            // Redirect back to the project page
            return redirect()->route('projects.show', $validated['project_id']);
        }
        
        // Redirect to the vulnerabilities index
        return redirect()->route('vulnerabilities.index');
    }

    /**
     * Display the specified resource.
     */
    public function show(Vulnerability $vulnerability)
    {
        $project = $vulnerability->project;
        $client = $project->client;
        
        return Inertia::render('vulnerabilities/show', [
            'vulnerability' => $vulnerability,
            'project' => $project,
            'client' => $client,
        ]);
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Vulnerability $vulnerability)
    {
        $project = $vulnerability->project;
        $client = $project->client;
        
        return Inertia::render('vulnerabilities/edit', [
            'vulnerability' => $vulnerability,
            'project' => $project,
            'client' => $client,
        ]);
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Vulnerability $vulnerability)
    {
        // Validate the request data
        $validated = $request->validate([
            'project_id' => 'required|exists:projects,id',
            'name' => 'required|string|max:255',
            'description' => 'required|string',
            'severity' => 'required|string|in:critical,high,medium,low,info',
            'cvss' => 'nullable|numeric|min:0|max:10',
            'cve' => 'nullable|string|max:255',
            'status' => 'required|string|in:open,in progress,fixed,won\'t fix',
            'remediation_steps' => 'nullable|string',
            'proof_of_concept' => 'nullable|string',
            'affected_components' => 'nullable|string',
            'notes' => 'nullable|string',
            'discovered_at' => 'nullable|date',
            'impact_score' => 'nullable|string|in:critical,high,medium,low,info',
            'likelihood_score' => 'nullable|string|in:critical,high,medium,low,info',
            'remediation_score' => 'nullable|string|in:critical,high,medium,low,info',
        ]);

        // Ensure severity and status are lowercase to match database constraints
        if (isset($validated['severity']) && $validated['severity'] !== null) {
            $validated['severity'] = strtolower($validated['severity']);
        }
        if (isset($validated['status']) && $validated['status'] !== null) {
            $validated['status'] = strtolower($validated['status']);
        }

        // Automatically set discovered_at to current time if not provided
        if (!isset($validated['discovered_at']) || empty($validated['discovered_at'])) {
            $validated['discovered_at'] = now();
        }

        // Update the vulnerability
        $vulnerability->update($validated);
        $vulnerability->updated_by = Auth::id();
        $vulnerability->save();

        // Check if we're coming from a project page
        if ($request->header('Referer') && strpos($request->header('Referer'), 'projects/') !== false) {
            // Redirect back to the project page
            return redirect()->route('projects.show', $vulnerability->project_id);
        }

        // Redirect back to the vulnerability details
        return redirect()->route('vulnerabilities.show', $vulnerability->id);
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Vulnerability $vulnerability)
    {
        // Delete the vulnerability
        $vulnerability->delete();

        // Return a 204 No Content response
        return response()->json(null, 204);
    }

    /**
     * Get common vulnerabilities for dashboard display.
     */
    public function commonVulnerabilities()
    {
        $vulnerabilities = Vulnerability::select('title', DB::raw('count(*) as count'))
            ->groupBy('title')
            ->orderBy('count', 'desc')
            ->take(5)
            ->get();
        return response()->json($vulnerabilities);
    }

    /**
     * Import vulnerability templates from a CSV/Excel file.
     */
    public function importTemplates(ImportTemplatesRequest $request)
    {
        try {
            // Log the file being uploaded at info level
            Log::info('Template import started', [
                'file_name' => $request->file('file')->getClientOriginalName(),
                'file_size' => $request->file('file')->getSize(),
                'mime_type' => $request->file('file')->getMimeType(),
                'user_id' => Auth::id(),
            ]);
            
            $importResult = $this->templateImportService->import($request->file('file'));
            
            // Log import results at debug level
            Log::debug('Import templates result:', $importResult);
            
            // Return a JSON response for AJAX requests
            return response()->json($importResult);
        } catch (\Exception $e) {
            // Log the exception with stack trace
            Log::error('Template import exception: ' . $e->getMessage(), [
                'exception' => get_class($e),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            return response()->json([
                'success' => false,
                'message' => 'Server error: ' . $e->getMessage(),
                'imported' => 0,
                'errors' => ['exception' => $e->getMessage()]
            ], 500);
        }
    }

    /**
     * Import vulnerabilities for a specific project from a CSV/Excel file.
     */
    public function importVulnerabilities(ImportVulnerabilitiesRequest $request)
    {
        try {
            // Log the file being uploaded at info level
            Log::info('Vulnerability import started', [
                'file_name' => $request->file('file')->getClientOriginalName(),
                'file_size' => $request->file('file')->getSize(),
                'mime_type' => $request->file('file')->getMimeType(),
                'project_id' => $request->input('project_id'),
                'user_id' => Auth::id(),
            ]);
            
            $importResult = $this->vulnerabilityImportService->import(
                $request->file('file'),
                $request->input('project_id')
            );
            
            // Log import results at debug level
            Log::debug('Import vulnerabilities result:', $importResult);
            
            // Check if it's an AJAX request
            if ($request->ajax() || $request->wantsJson()) {
                // Return a JSON response for AJAX requests
                return response()->json($importResult);
            }
            
            // For regular requests, redirect back with flash message
            if ($importResult['success']) {
                return redirect()->back()->with('success', "Successfully imported {$importResult['imported']} vulnerability/vulnerabilities.");
            } else {
                return redirect()->back()->with('error', $importResult['message'])->with('import_results', $importResult);
            }
        } catch (\Exception $e) {
            // Log the exception with stack trace
            Log::error('Vulnerability import exception: ' . $e->getMessage(), [
                'exception' => get_class($e),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString(),
                'project_id' => $request->input('project_id'),
            ]);
            
            // Return JSON for AJAX requests
            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Server error: ' . $e->getMessage(),
                    'imported' => 0,
                    'errors' => ['exception' => $e->getMessage()]
                ], 500);
            }
            
            // For regular requests, redirect back with error
            return redirect()->back()->with('error', 'Server error: ' . $e->getMessage());
        }
    }

    /**
     * Generate and download a sample CSV template for vulnerability imports.
     */
    public function downloadVulnerabilitySampleTemplate()
    {
        $headers = [
            'name', 'description', 'severity', 'cvss', 'cve', 
            'recommendations', 'impact', 'references', 'tags'
        ];
        
        $sampleData = [
            [
                'name' => 'SQL Injection in Login Form',
                'description' => 'The login form is vulnerable to SQL injection attacks.',
                'severity' => 'High',
                'cvss' => '8.5',
                'cve' => 'CVE-2023-1234',
                'recommendations' => 'Use parameterized queries or prepared statements.',
                'impact' => 'Attackers could access unauthorized data or execute commands on the database server.',
                'references' => 'https://owasp.org/www-community/attacks/SQL_Injection',
                'tags' => 'sql-injection,authentication'
            ],
            [
                'name' => 'Cross-Site Scripting in Search Form',
                'description' => 'The search form does not properly sanitize user input, leading to XSS vulnerabilities.',
                'severity' => 'Medium',
                'cvss' => '6.1',
                'cve' => 'CVE-2023-5678',
                'recommendations' => 'Implement proper input validation and output encoding.',
                'impact' => 'Attackers could inject malicious scripts that execute in users\' browsers.',
                'references' => 'https://owasp.org/www-community/attacks/xss/',
                'tags' => 'xss,input-validation'
            ]
        ];
        
        return $this->generateCsvResponse($headers, $sampleData, 'vulnerability_import_template.csv');
    }

    /**
     * Generate and download a sample CSV template for template imports.
     */
    public function downloadTemplateSampleTemplate()
    {
        $headers = [
            'name', 'description', 'severity'
        ];
        
        $sampleData = [
            [
                'name' => 'SQL Injection Template',
                'description' => 'SQL injection is a code injection technique that might destroy your database.',
                'severity' => 'High'
            ],
            [
                'name' => 'Cross-Site Scripting Template',
                'description' => 'XSS enables attackers to inject client-side scripts into web pages viewed by other users.',
                'severity' => 'Medium'
            ]
        ];
        
        return $this->generateCsvResponse($headers, $sampleData, 'template_import_template.csv');
    }

    private function generateCsvResponse($headers, $data, $filename)
    {
        $callback = function() use ($headers, $data) {
            $file = fopen('php://output', 'w');
            fputcsv($file, $headers);
            
            foreach ($data as $row) {
                fputcsv($file, $row);
            }
            
            fclose($file);
        };
        
        return response()->stream($callback, 200, [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => 'attachment; filename="' . $filename . '"',
        ]);
    }
}
