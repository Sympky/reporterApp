<?php

namespace App\Services;

use App\Models\Vulnerability;
use App\Models\Project;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;
use Maatwebsite\Excel\Facades\Excel;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Collection;
use Exception;
use Illuminate\Validation\ValidationException;
use Illuminate\Support\Facades\DB;

class VulnerabilityImportService
{
    /**
     * Import vulnerabilities from a CSV/Excel file
     *
     * @param UploadedFile $file The uploaded file
     * @param int $projectId The project ID to associate with the vulnerabilities
     * @param bool $isTemplate Whether the vulnerabilities should be imported as templates
     * @return array The import results, including success count and errors
     */
    public function import(UploadedFile $file, int $projectId = null, bool $isTemplate = false): array
    {
        try {
            // Log important info for debugging
            Log::info('Starting import process', [
                'file_name' => $file->getClientOriginalName(),
                'file_size' => $file->getSize(),
                'file_mime' => $file->getMimeType(),
                'is_template' => $isTemplate,
                'project_id' => $projectId,
                'user_id' => Auth::id()
            ]);
            
            // Check file extension
            $extension = strtolower($file->getClientOriginalExtension());
            if (!in_array($extension, ['csv', 'xlsx', 'xls'])) {
                Log::warning('Invalid file format', ['extension' => $extension]);
                return [
                    'success' => false,
                    'message' => 'Invalid file format. Please upload a CSV or Excel file.',
                    'imported' => 0,
                    'errors' => []
                ];
            }
            
            try {
                // Parse the file into an array of rows
                $contents = file_get_contents($file->getRealPath());
                
                // Log the first 200 bytes of the file to check format
                Log::debug('File content preview (first 200 bytes):', [
                    'content' => substr($contents, 0, 200),
                    'encoding' => mb_detect_encoding($contents),
                    'length' => strlen($contents)
                ]);
                
                // Try to parse with Excel
                $rows = Excel::toCollection(new class {}, $file)->flatten(1);
                
                Log::info('File parsed successfully', [
                    'row_count' => $rows->count(),
                    'first_row' => $rows->first() ? $rows->first()->toArray() : null,
                    'file_size' => $file->getSize(),
                    'extension' => $file->getClientOriginalExtension()
                ]);
            } catch (Exception $e) {
                Log::error('Excel parsing error: ' . $e->getMessage(), [
                    'exception' => get_class($e),
                    'file' => $e->getFile(),
                    'line' => $e->getLine(),
                    'trace' => $e->getTraceAsString(),
                    'file_name' => $file->getClientOriginalName(),
                    'file_size' => $file->getSize(),
                    'mime_type' => $file->getMimeType()
                ]);
                return [
                    'success' => false,
                    'message' => 'Failed to parse the file. Please ensure it is a valid CSV or Excel file with the correct format.',
                    'imported' => 0,
                    'errors' => []
                ];
            }
            
            if ($rows->isEmpty()) {
                Log::warning('Empty file uploaded');
                return [
                    'success' => false,
                    'message' => 'The uploaded file is empty. Please check the file and try again.',
                    'imported' => 0,
                    'errors' => []
                ];
            }
            
            // First row should contain headers
            $headers = $rows->first()->keys()->toArray();
            Log::info('File headers (original)', ['headers' => $headers]);

            // Check if headers are numeric (0, 1, 2, 3, etc.)
            $allNumericHeaders = true;
            foreach ($headers as $header) {
                if (!is_numeric($header)) {
                    $allNumericHeaders = false;
                    break;
                }
            }
            
            // If all headers are numeric, this might be a CSV without a header row
            // OR it could be a CSV with headers but Excel is treating the first row as data instead of headers
            // In this case, we'll try to use the first row values as headers
            if ($allNumericHeaders && $rows->count() > 0) {
                Log::warning('Detected numeric headers, attempting to use first row values as headers', [
                    'numeric_headers' => $headers,
                    'first_row_values' => $rows->first()->values()->toArray()
                ]);
                
                // Use the first row values as headers
                $firstRowValues = $rows->first()->values()->toArray();
                
                // Create a new collection with proper headers from the data including the first row
                $newRows = collect();
                $newFirstRow = [];
                
                // Map the first row values to headers
                foreach ($firstRowValues as $index => $value) {
                    $newFirstRow[(string)$index] = $value;
                }
                
                // Add the rest of the rows with the same numeric headers
                $newRows->push(collect($newFirstRow));
                $rows->skip(1)->each(function ($row) use (&$newRows) {
                    $newRows->push($row);
                });
                
                // Replace the original rows with our new collection
                $rows = $newRows;
                
                // Update headers to be the first row values
                $headers = $firstRowValues;
                Log::info('Using first row values as headers', ['new_headers' => $headers]);
            }

            // Get the required headers based on whether we're importing templates
            $requiredHeaders = $isTemplate
                ? ['name', 'description', 'severity']
                : ['name', 'description', 'severity'];
            
            // Normalize required headers for comparison
            $normalizedRequiredHeaders = array_map(function ($header) {
                return strtolower(trim(preg_replace('/[^a-zA-Z0-9]/', '', $header)));
            }, $requiredHeaders);
            
            // Normalize headers from the file
            $normalizedHeaders = array_map(function ($header) {
                // Convert to lowercase, remove non-alphanumeric characters and trim
                if (is_numeric($header)) {
                    // If header is numeric, just return it as a string
                    return (string)$header;
                }
                return strtolower(trim(preg_replace('/[^a-zA-Z0-9]/', '', $header)));
            }, $headers);
            
            // Map common variations of the required headers
            $headerAliases = [
                'name' => ['name', 'title', 'header', 'vuln', 'vulnerability', 'vulnname', 'vulnerability_name', 'issue', 'issuename', 'issue_name'],
                'description' => ['description', 'desc', 'details', 'overview', 'summary', 'information', 'info', 'vulndesc', 'vulnerability_description'],
                'severity' => ['severity', 'risk', 'level', 'impact', 'priority', 'criticality', 'sev', 'vulnseverity', 'vulnerability_severity', 'risk_level']
            ];

            // For each normalized header, check if it matches any of the aliases
            $headerMatches = [];
            foreach ($normalizedHeaders as $index => $normalizedHeader) {
                $origHeader = $headers[$index];
                $matchFound = false;
                
                // Skip if it's a numeric header and we don't have header aliases
                if (is_numeric($normalizedHeader)) {
                    continue;
                }
                
                foreach ($headerAliases as $requiredHeader => $aliases) {
                    if (in_array($normalizedHeader, $aliases)) {
                        $headerMatches[$requiredHeader] = $origHeader;
                        $matchFound = true;
                        break;
                    }
                }
                
                if (!$matchFound) {
                    // Check for partial matches (contains the required header as substring)
                    foreach ($headerAliases as $requiredHeader => $aliases) {
                        foreach ($aliases as $alias) {
                            if (strpos($normalizedHeader, $alias) !== false) {
                                $headerMatches[$requiredHeader] = $origHeader;
                                break 2;
                            }
                        }
                    }
                }
            }
            
            Log::info('Header matches found', ['matches' => $headerMatches]);
            
            // Create a map of normalized headers to original headers for error messages
            $headerMap = [];
            foreach ($headers as $header) {
                $normalized = is_numeric($header) ? (string)$header : strtolower(trim(preg_replace('/[^a-zA-Z0-9]/', '', $header)));
                $headerMap[$normalized] = $header;
            }
            
            // Log the headers we found
            Log::info('Found headers in file (normalized)', [
                'headers' => $normalizedHeaders,
                'header_map' => $headerMap
            ]);
            Log::info('Required headers (normalized)', ['headers' => $normalizedRequiredHeaders]);
            
            // Check if we have all the required headers based on header matches
            $missingHeaders = [];
            foreach ($requiredHeaders as $requiredHeader) {
                if (!isset($headerMatches[$requiredHeader])) {
                    $missingHeaders[] = $requiredHeader;
                }
            }
            
            // If we're still missing headers, try the traditional comparison
            if (empty($missingHeaders)) {
                Log::info('All required headers found using header matching');
            } else {
                Log::warning('Some headers not found using header matching, trying traditional comparison', [
                    'missing' => $missingHeaders
                ]);
                
                // Compare the normalized headers
                $missingHeaders = array_diff($normalizedRequiredHeaders, $normalizedHeaders);
            }
            
            // If we still have missing headers, try a more flexible 'fuzzy' matching approach
            if (!empty($missingHeaders)) {
                Log::info('Attempting fuzzy header matching', ['missing' => $missingHeaders]);
                
                // Create fuzzy matches by checking for partial matches
                $fuzzyMatches = [];
                foreach ($missingHeaders as $missingHeader) {
                    foreach ($normalizedHeaders as $existingHeader) {
                        // Check for substring matches
                        if (strpos($existingHeader, $missingHeader) !== false || 
                            strpos($missingHeader, $existingHeader) !== false) {
                            $fuzzyMatches[$missingHeader] = $existingHeader;
                            break;
                        }
                    }
                }
                
                if (!empty($fuzzyMatches)) {
                    Log::info('Found fuzzy matches for headers', ['matches' => $fuzzyMatches]);
                    
                    // Remove the matched headers from our missing list
                    $missingHeaders = array_diff($missingHeaders, array_keys($fuzzyMatches));
                    
                    // Add a log of the matches we found
                    Log::info('Remaining missing headers after fuzzy matching', ['remaining' => $missingHeaders]);
                    
                    // Add fuzzy matches to our headerMatches array
                    foreach ($fuzzyMatches as $requiredHeader => $matchedHeader) {
                        $headerMatches[$requiredHeader] = $headerMap[$matchedHeader] ?? $matchedHeader;
                    }
                }
            }
            
            // If we still have missing headers, generate user-friendly message
            if (!empty($missingHeaders)) {
                Log::warning('Missing required headers', ['missing' => $missingHeaders]);
                
                // Generate helpful suggestions for the user
                $suggestions = [];
                foreach ($missingHeaders as $missingHeader) {
                    $suggestions[] = "- '$missingHeader': Use one of these headers: " . implode(', ', $headerAliases[$missingHeader] ?? [$missingHeader]);
                }
                
                $errorMessage = 'The uploaded file is missing required headers: ' . implode(', ', $missingHeaders);
                $errorMessage .= "\n\nSuggestions:\n" . implode("\n", $suggestions);
                
                return [
                    'success' => false,
                    'message' => $errorMessage,
                    'imported' => 0,
                    'errors' => [
                        'required_headers' => $requiredHeaders,
                        'found_headers' => $headers,
                        'normalized_found' => $normalizedHeaders,
                        'suggestions' => $suggestions
                    ]
                ];
            }
            
            // At this point, we have all the required headers, update the rows for proper column access
            // Map the headers to their required names for consistent access
            if (!empty($headerMatches) && count($headerMatches) >= count($requiredHeaders)) {
                Log::info('Mapping headers to required names', ['mapping' => $headerMatches]);
                
                // Create a new collection with the updated headers
                $newRows = collect();
                
                // Process each row, mapping the original headers to the required ones
                $rows->each(function ($row, $index) use (&$newRows, $headerMatches, $headers) {
                    $newRow = collect();
                    
                    // First add all the original data
                    foreach ($row as $key => $value) {
                        $newRow->put($key, $value);
                    }
                    
                    // Log the row data before header mapping
                    if ($index < 3) {  // Only log first few rows to avoid log spam
                        Log::info('Row data before header mapping', [
                            'row_index' => $index,
                            'row_data' => $row->toArray(),
                            'headers' => $headers
                        ]);
                    }
                    
                    // Then add/update with the required header mappings
                    foreach ($headerMatches as $requiredHeader => $originalHeader) {
                        // Find the key in the original row that matches the original header
                        $originalKey = array_search($originalHeader, $headers);
                        if ($originalKey !== false) {
                            $newRow->put($requiredHeader, $row[$originalKey] ?? null);
                        }
                    }
                    
                    // Log the transformed row
                    if ($index < 3) {  // Only log first few rows
                        Log::info('Row data after header mapping', [
                            'row_index' => $index,
                            'mapped_row' => $newRow->toArray()
                        ]);
                    }
                    
                    $newRows->push($newRow);
                });
                
                // Replace the original rows with our new collection
                $rows = $newRows;
                
                Log::info('Headers remapped successfully', [
                    'sample_row' => $rows->first() ? $rows->first()->toArray() : null
                ]);
            }
            
            // Process each row except the first one (headers)
            $results = [
                'success' => true,
                'message' => 'Import completed successfully',
                'imported' => 0,
                'errors' => []
            ];
            
            // Verify project exists if not a template
            if (!$isTemplate && $projectId) {
                $project = Project::find($projectId);
                if (!$project) {
                    return [
                        'success' => false,
                        'message' => 'Project not found with ID: ' . $projectId,
                        'imported' => 0,
                        'errors' => []
                    ];
                }
            }
            
            // Begin database transaction to ensure all-or-nothing import
            DB::beginTransaction();
            
            try {
                $rows->skip(1)->each(function ($row, $index) use (&$results, $projectId, $isTemplate) {
                    try {
                        // Convert row to array and handle empty/null values
                        $rowData = collect($row)->map(function ($value) {
                            return is_null($value) ? '' : $value;
                        })->toArray();
                        
                        // Log the raw row data for debugging
                        Log::info('Processing row with raw data:', [
                            'row_index' => $index + 2,
                            'raw_row' => $rowData,
                            'keys' => array_keys($rowData)
                        ]);
                        
                        // Extract data from numeric keys (0,1,2...) which contain our actual CSV data
                        // This is crucial since the header mapping isn't working correctly
                        $numericKeyData = [];
                        foreach ($rowData as $key => $value) {
                            if (is_numeric($key)) {
                                $numericKeyData[$key] = $value;
                            }
                        }
                        
                        // Map numeric keys to actual field names - based on the CSV file structure
                        // We know the order from the logs: name,description,severity,cvss,cve,recommendations,impact,references,tags
                        $mappedData = [
                            'name' => $numericKeyData[0] ?? '',
                            'description' => $numericKeyData[1] ?? '',
                            'severity' => $numericKeyData[2] ?? 'Medium',
                            'cvss' => $numericKeyData[3] ?? null,
                            'cve' => $numericKeyData[4] ?? '',
                            'recommendations' => $numericKeyData[5] ?? '',
                            'impact' => $numericKeyData[6] ?? '',
                            'references' => $numericKeyData[7] ?? '',
                            'tags' => $numericKeyData[8] ?? '',
                        ];
                        
                        // Log the mapped data
                        Log::info('Explicitly mapped data from CSV:', [
                            'row_index' => $index + 2,
                            'mapped_data' => $mappedData
                        ]);
                        
                        // Override with any already correctly mapped named fields
                        foreach (['name', 'description', 'severity'] as $field) {
                            if (isset($rowData[$field]) && !empty($rowData[$field])) {
                                $mappedData[$field] = $rowData[$field];
                            }
                        }
                        
                        // Normalize severity values before validation
                        if (isset($mappedData['severity']) && !empty($mappedData['severity'])) {
                            // Map of common severity values to their canonical form
                            $severityMap = [
                                // Critical variants
                                'critical' => 'Critical',
                                'crit' => 'Critical',
                                'c' => 'Critical',
                                
                                // High variants
                                'high' => 'High',
                                'h' => 'High',
                                'severe' => 'High',
                                
                                // Medium variants
                                'medium' => 'Medium',
                                'med' => 'Medium',
                                'm' => 'Medium',
                                'moderate' => 'Medium',
                                
                                // Low variants
                                'low' => 'Low',
                                'l' => 'Low',
                                'minor' => 'Low',
                                
                                // Info variants
                                'info' => 'Info',
                                'information' => 'Info',
                                'i' => 'Info',
                                'informational' => 'Info'
                            ];
                            
                            // Convert to lowercase for case-insensitive matching
                            $severityLower = strtolower(trim($mappedData['severity']));
                            
                            // Check for exact match
                            if (isset($severityMap[$severityLower])) {
                                $mappedData['severity'] = $severityMap[$severityLower];
                            }
                            // Try to match by substring (for values like "Critical Risk")
                            else {
                                $matched = false;
                                foreach (['Critical', 'High', 'Medium', 'Low', 'Info'] as $validSeverity) {
                                    if (stripos($severityLower, strtolower($validSeverity)) !== false) {
                                        $mappedData['severity'] = $validSeverity;
                                        $matched = true;
                                        break;
                                    }
                                }
                                
                                // If no match found, use a numeric mapping or default to Medium
                                if (!$matched) {
                                    // Log at lowest level since this is expected behavior
                                    Log::debug('Normalizing non-standard severity value', [
                                        'original_value' => $mappedData['severity'],
                                        'normalized_value' => $severityLower
                                    ]);
                                    
                                    // Try numeric severity (1-5 or 1-10 scale)
                                    if (is_numeric($severityLower)) {
                                        $numericValue = (float) $severityLower;
                                        
                                        // Assuming 1-5 scale
                                        if ($numericValue <= 5) {
                                            if ($numericValue >= 4.5) $mappedData['severity'] = 'Critical';
                                            else if ($numericValue >= 3.5) $mappedData['severity'] = 'High';
                                            else if ($numericValue >= 2.5) $mappedData['severity'] = 'Medium';
                                            else if ($numericValue >= 1.5) $mappedData['severity'] = 'Low';
                                            else $mappedData['severity'] = 'Info';
                                        }
                                        // Assuming 1-10 scale (like CVSS)
                                        else {
                                            if ($numericValue >= 9.0) $mappedData['severity'] = 'Critical';
                                            else if ($numericValue >= 7.0) $mappedData['severity'] = 'High';
                                            else if ($numericValue >= 4.0) $mappedData['severity'] = 'Medium';
                                            else if ($numericValue >= 0.1) $mappedData['severity'] = 'Low';
                                            else $mappedData['severity'] = 'Info';
                                        }
                                    }
                                    // Default to Medium if all else fails
                                    else {
                                        $mappedData['severity'] = 'Medium';
                                    }
                                }
                            }
                        }
                        
                        // Handle CVSS specifically to ensure it's a number or null
                        if (isset($mappedData['cvss']) && $mappedData['cvss'] !== '' && is_numeric($mappedData['cvss'])) {
                            $mappedData['cvss'] = floatval($mappedData['cvss']);
                        } else {
                            $mappedData['cvss'] = null;
                        }
                        
                        // Validate row data
                        $validator = Validator::make($mappedData, [
                            'name' => 'required|string|max:255',
                            'description' => 'nullable|string',
                            'severity' => 'nullable|string|in:Critical,High,Medium,Low,Info',
                            'cvss' => 'nullable|numeric|min:0|max:10',
                            'cve' => 'nullable|string|max:255',
                            'recommendations' => 'nullable|string',
                            'impact' => 'nullable|string',
                            'references' => 'nullable|string',
                            'tags' => 'nullable|string',
                        ], [
                            'severity.in' => "The severity value has been normalized to a standard value."
                        ]);
                        
                        if ($validator->fails()) {
                            throw new ValidationException($validator);
                        }
                        
                        // Prepare the data to import with safe defaults
                        $importData = [
                            'name' => $mappedData['name'],
                            'description' => $mappedData['description'] ?? '',
                            'severity' => strtolower($mappedData['severity'] ?? 'Low'),
                            'cvss' => $mappedData['cvss'],
                            'cve' => $mappedData['cve'] ?? '',
                            'recommendations' => $mappedData['recommendations'] ?? '',
                            'remediation_steps' => $mappedData['recommendations'] ?? '', // Copy recommendations to remediation_steps
                            'impact' => $mappedData['impact'] ?? '',
                            'references' => $mappedData['references'] ?? '',
                            'tags' => $this->formatTags($mappedData['tags'] ?? ''),
                            'is_template' => $isTemplate,
                            'status' => $isTemplate ? null : 'open',
                            'created_by' => Auth::id(),
                            'updated_by' => Auth::id(),
                        ];
                        
                        // Log the data before creating the vulnerability
                        Log::info('Creating vulnerability with data:', [
                            'row_index' => $index + 2,
                            'raw_data' => $rowData,
                            'mapped_data' => $mappedData,
                            'import_data' => $importData,
                            'is_template' => $isTemplate,
                            'project_id' => $projectId
                        ]);
                        
                        // Add project_id if not a template
                        if (!$isTemplate && $projectId) {
                            $importData['project_id'] = $projectId;
                            Log::info('Setting project_id for vulnerability', [
                                'project_id' => $projectId,
                                'row_index' => $index + 2
                            ]);
                        } else if (!$isTemplate) {
                            Log::warning('No project_id provided for non-template vulnerability', [
                                'row_index' => $index + 2
                            ]);
                        }
                        
                        // Create the vulnerability record
                        $vulnerability = new Vulnerability();
                        $vulnerability->fill($importData);
                        $vulnerability->save();
                        
                        // Double check that all fields were saved correctly
                        $savedVulnerability = Vulnerability::find($vulnerability->id);
                        Log::info('Saved vulnerability data:', [
                            'id' => $savedVulnerability->id,
                            'name' => $savedVulnerability->name,
                            'description' => $savedVulnerability->description,
                            'severity' => $savedVulnerability->severity,
                            'project_id' => $savedVulnerability->project_id,
                            'cvss' => $savedVulnerability->cvss,
                            'cve' => $savedVulnerability->cve,
                            'recommendations' => $savedVulnerability->recommendations,
                            'remediation_steps' => $savedVulnerability->remediation_steps,
                            'impact' => $savedVulnerability->impact,
                            'references' => $savedVulnerability->references,
                            'tags' => $savedVulnerability->tags,
                        ]);
                        
                        $results['imported']++;
                        
                    } catch (ValidationException $e) {
                        // Add validation errors to results
                        $results['errors'][] = [
                            'row' => $index + 2, // +2 because we're skipping header and index is 0-based
                            'errors' => $e->errors()
                        ];
                    } catch (Exception $e) {
                        // Check for undefined array key errors
                        $errorMessage = $e->getMessage();
                        if (strpos($errorMessage, 'Undefined array key') !== false) {
                            // Extract the field name from the error message
                            preg_match('/Undefined array key "(.*?)"/', $errorMessage, $matches);
                            $missingField = $matches[1] ?? 'unknown field';
                            
                            Log::warning('Missing field in import data', [
                                'field' => $missingField,
                                'row' => $index + 2,
                                'error' => $errorMessage
                            ]);
                            
                            // Add a more helpful error message
                            $results['errors'][] = [
                                'row' => $index + 2,
                                'errors' => [
                                    'missing_field' => ["The field '{$missingField}' is missing. Please ensure your CSV includes all required fields."]
                                ]
                            ];
                        } else {
                            // Add general errors to results
                            $results['errors'][] = [
                                'row' => $index + 2,
                                'errors' => ['general' => [$e->getMessage()]]
                            ];
                        }
                    }
                });
                
                // Commit the transaction if everything went well
                DB::commit();
                
                // Update success status based on errors
                if (count($results['errors']) > 0) {
                    $results['success'] = $results['imported'] > 0;
                    $results['message'] = $results['imported'] > 0 
                        ? 'Import completed with some errors.' 
                        : 'Import failed. Please check the errors and try again.';
                }
                
                return $results;
            } catch (Exception $e) {
                // Rollback the transaction if an error occurred
                DB::rollBack();
                
                Log::error('Transaction error during import: ' . $e->getMessage());
                return [
                    'success' => false,
                    'message' => 'An error occurred during import: ' . $e->getMessage(),
                    'imported' => 0,
                    'errors' => []
                ];
            }
        } catch (Exception $e) {
            Log::error('Vulnerability import error: ' . $e->getMessage());
            return [
                'success' => false,
                'message' => 'Failed to process the file: ' . $e->getMessage(),
                'imported' => 0,
                'errors' => []
            ];
        }
    }
    
    /**
     * Format tags string into an array
     *
     * @param string $tags Comma-separated tags or JSON string
     * @return array The formatted tags array
     */
    protected function formatTags(string $tags): array
    {
        if (empty($tags)) {
            return [];
        }
        
        // Log the input for debugging
        Log::info('Processing tags input', ['tags_input' => $tags]);
        
        // Check if it's a JSON array
        if (substr($tags, 0, 1) === '[' && substr($tags, -1) === ']') {
            try {
                $decodedTags = json_decode($tags, true);
                if (is_array($decodedTags)) {
                    return $decodedTags;
                }
            } catch (Exception $e) {
                // If JSON parsing fails, continue to treat as comma-separated
                Log::warning('Failed to parse tags as JSON', ['error' => $e->getMessage()]);
            }
        }
        
        // Split by comma
        $tagArray = array_map('trim', explode(',', $tags));
        
        // Remove any empty elements
        $tagArray = array_filter($tagArray, function($tag) {
            return !empty($tag);
        });
        
        // Log the output for debugging
        Log::info('Processed tags', ['tags_output' => $tagArray]);
        
        return $tagArray;
    }
} 